import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';

const wrapText = (text, font, fontSize, maxWidth) => {
  const words = text.split(/\s+/);
  const lines = [];
  let current = '';

  for (const word of words) {
    const tentative = current ? `${current} ${word}` : word;
    const width = font.widthOfTextAtSize(tentative, fontSize);
    if (width <= maxWidth) {
      current = tentative;
    } else {
      if (current) lines.push(current);
      current = word;
    }
  }
  if (current) lines.push(current);
  return lines;
};

export const generateContractPdf = async ({
  contractTitle,
  contractVersion,
  contractText,
  typedName,
  email,
  signedAt,
  signedIp,
  signatureDataUrl,
  signatureUuid,
}) => {
  const pdfDoc = await PDFDocument.create();
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const bold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const margin = 42;
  const pageWidth = 612;
  const pageHeight = 792;

  let page = pdfDoc.addPage([pageWidth, pageHeight]);
  let y = pageHeight - margin;

  const ensureSpace = (heightNeeded) => {
    if (y - heightNeeded < margin) {
      page = pdfDoc.addPage([pageWidth, pageHeight]);
      y = pageHeight - margin;
    }
  };

  const headerTitle = contractTitle || 'Contract';
  const headerSubtitle = `Version ${contractVersion || '1.0'} • Signature UUID ${signatureUuid}`;
  const signedDate = signedAt instanceof Date ? signedAt : new Date(signedAt || Date.now());

  page.drawText(headerTitle, {
    x: margin,
    y,
    size: 18,
    font: bold,
    color: rgb(0.15, 0.18, 0.25),
  });
  y -= 20;

  page.drawText(headerSubtitle, {
    x: margin,
    y,
    size: 10,
    font,
    color: rgb(0.35, 0.4, 0.45),
  });
  y -= 24;

  const metaLines = [
    `Executed by: ${typedName}`,
    `Email: ${email || '—'}`,
    `Signed at: ${signedDate.toISOString()}`,
    `Signed IP: ${signedIp || 'Captured server-side'}`,
  ];

  metaLines.forEach((line) => {
    page.drawText(line, {
      x: margin,
      y,
      size: 10,
      font,
      color: rgb(0.3, 0.35, 0.4),
    });
    y -= 14;
  });

  y -= 6;
  page.drawLine({
    start: { x: margin, y },
    end: { x: pageWidth - margin, y },
    thickness: 0.6,
    color: rgb(0.85, 0.88, 0.92),
  });
  y -= 20;

  const clauses = contractText?.split(/\n\n+/) || ['Contract terms unavailable'];
  const lineHeight = 14;
  const maxWidth = pageWidth - margin * 2;
  const fontSize = 11;

  clauses.forEach((clause, idx) => {
    const title = `Section ${idx + 1}`;
    ensureSpace(36);
    page.drawText(title, {
      x: margin,
      y,
      size: 12,
      font: bold,
      color: rgb(0.18, 0.22, 0.3),
    });
    y -= 16;

    const wrapped = wrapText(clause.trim(), font, fontSize, maxWidth);
    wrapped.forEach((line) => {
      ensureSpace(lineHeight);
      page.drawText(line, { x: margin, y, size: fontSize, font, color: rgb(0.15, 0.18, 0.2) });
      y -= lineHeight;
    });

    y -= 10;
  });

  ensureSpace(140);
  page.drawLine({
    start: { x: margin, y },
    end: { x: pageWidth - margin, y },
    thickness: 0.8,
    color: rgb(0.75, 0.8, 0.85),
  });
  y -= 20;

  page.drawText('Execution Details', {
    x: margin,
    y,
    size: 13,
    font: bold,
    color: rgb(0.12, 0.16, 0.26),
  });
  y -= 18;

  const executionLines = [
    `Typed Name: ${typedName}`,
    `Email: ${email || '—'}`,
    `Signed Date: ${signedDate.toISOString()}`,
    `IP Address: ${signedIp || 'Captured server-side'}`,
    `Contract Version: ${contractVersion || '1.0'}`,
    `Signature UUID: ${signatureUuid}`,
  ];

  executionLines.forEach((line) => {
    ensureSpace(lineHeight);
    page.drawText(line, { x: margin, y, size: fontSize, font, color: rgb(0.2, 0.24, 0.28) });
    y -= lineHeight;
  });

  if (signatureDataUrl) {
    const base64 = signatureDataUrl.split(',')[1];
    if (base64) {
      const pngImage = await pdfDoc.embedPng(Buffer.from(base64, 'base64'));
      const pngDims = pngImage.scale(0.5);
      const sigHeight = pngDims.height;
      ensureSpace(sigHeight + 36);

      page.drawText('Signature:', {
        x: margin,
        y,
        size: 11,
        font: bold,
        color: rgb(0.2, 0.24, 0.28),
      });
      y -= 6 + sigHeight;

      page.drawImage(pngImage, {
        x: margin,
        y,
        width: pngDims.width,
        height: pngDims.height,
      });
      y -= 14;
    }
  }

  pdfDoc.setTitle(`${headerTitle} (Executed)`);
  pdfDoc.setSubject('Executed contract generated by Noble Web Designs');
  pdfDoc.setCreator('Noble Web Designs eSignature');
  pdfDoc.setProducer('Noble Web Designs');

  const pdfBytes = await pdfDoc.save({ useObjectStreams: true });
  return pdfBytes;
};

const parsePlacements = (placements) => {
  if (!placements) return null;
  if (typeof placements === 'string') {
    try {
      return JSON.parse(placements);
    } catch {
      return null;
    }
  }
  return placements;
};

export const generateContractPdfFromTemplate = async ({
  templatePdfBytes,
  typedName,
  email,
  signedAt,
  signedIp,
  signatureDataUrl,
  signatureUuid,
  contractVersion,
  placements,
}) => {
  const parsed = parsePlacements(placements);
  const pdfDoc = await PDFDocument.load(templatePdfBytes);
  const pages = pdfDoc.getPages();
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const bold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const sig = parsed?.signature || { page: 1, x: 180, y: 120, width: 240, height: 80 };
  const namePos = parsed?.name || { page: sig.page, x: sig.x, y: sig.y - 16 };
  const emailPos = parsed?.email || { page: sig.page, x: sig.x, y: sig.y - 32 };
  const datePos = parsed?.date || { page: sig.page, x: sig.x, y: sig.y - 48 };
  const ipPos = parsed?.ip || { page: sig.page, x: sig.x, y: sig.y - 64 };
  const versionPos = parsed?.version || { page: sig.page, x: sig.x, y: sig.y - 80 };

  const targetPage = pages[(sig.page || 1) - 1] || pages[0];

  if (signatureDataUrl) {
    const base64 = signatureDataUrl.split(',')[1];
    if (base64) {
      const pngImage = await pdfDoc.embedPng(Buffer.from(base64, 'base64'));
      targetPage.drawImage(pngImage, {
        x: sig.x,
        y: sig.y,
        width: sig.width || 240,
        height: sig.height || 80,
      });
    }
  }

  const signedDate = signedAt instanceof Date ? signedAt : new Date(signedAt || Date.now());
  const textColor = rgb(0.1, 0.12, 0.16);
  const textSize = 10;

  targetPage.drawText(typedName || '', { x: namePos.x, y: namePos.y, size: textSize, font: bold, color: textColor });
  targetPage.drawText(email || '', { x: emailPos.x, y: emailPos.y, size: textSize, font, color: textColor });
  targetPage.drawText(signedDate.toISOString(), { x: datePos.x, y: datePos.y, size: textSize, font, color: textColor });
  targetPage.drawText(signedIp || 'Captured server-side', { x: ipPos.x, y: ipPos.y, size: textSize, font, color: textColor });
  targetPage.drawText(`Version ${contractVersion || '1.0'} • ${signatureUuid}`, {
    x: versionPos.x,
    y: versionPos.y,
    size: textSize,
    font,
    color: textColor,
  });

  pdfDoc.setTitle(`Executed Contract ${signatureUuid || ''}`);
  const pdfBytes = await pdfDoc.save({ useObjectStreams: true });
  return pdfBytes;
};
